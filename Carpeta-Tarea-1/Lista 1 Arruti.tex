\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{mathrsfs}
\usepackage[spanish,es-lcroman]{babel}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage{eufrak}
\usepackage{nicefrac}
\usepackage{amsmath,stackengine,scalerel,mathtools}
\usepackage{tikz-cd}
\usepackage{comment}%Paquete para añadir comentarios largos.}

%Imprime el símbolo de subideal, o bien subgrupo normal
\def\subnormeq{\mathrel{\scalerel*{\trianglelefteq}{A}}}

%Recibe un paremetro y le coloca dos barras a cada lado, por ejemplo para denotar la cardinalidad. Así $\crdnlty{A}$ imprime |A| 
\newcommand{\crdnlty}[1]{
    \left|#1\right|
}

%Recibe un paremetro y le coloca paréntesis a cada lado, por ejemplo para construir un conjunto. Así $\lrprth{A}$ imprime (A). Lo conveniente del comando es que los paréntesis se ajustan al tamaño del argumento, de modo que si uno introduce, por ejemplo, un cociente, el tamaño de los paréntesis se ajustan a este. Lo mismo sucede con lrbrack, que coloca llaves, y lo hace útil para definir familias o conjuntos. 
\newcommand{\lrprth}[1]{
    \left(#1\right)
}

%Idéntico al comando anterior, pero con llaves {}
\newcommand{\lrbrack}[1]{
    \left\{#1\right\}
}

\begin{comment}
Recibe 3 parámetros y con ellos crea un conjunto, de la siguiente manera:
$\descset{a}{A}{p}$ imprime {a \in A | p}
a son elementos, A es el conjunto del que se toman, y p es la propiedad que deben satisfacer los elementos para pertenecer al conjunto
\end{comment}
\newcommand{\descset}[3]{
    \left\{#1\in#2\ \vline\ #3\right\}
}

\begin{comment}
Recibe seis parámetros, con los cuales construye una aplicación (que puede terminar siendo una función). El primer parámetro es el símbolo que tendra la aplicación, por ejemplo f, el segundo es el dominio de la aplicación, el tercero es el contradominio de la aplicación, el cuarto es el símbolo con el que se denota un elemento del dominio, el quinto es la imagen hacia la que se va a mapear el elemento, y el sexto es un símbolo (que puede ser una coma, un punto, dejarse en blanco, etcétera) para separar la aplicación del texto que vendrá después. Vean qué imprime el siguiente código:
\begin{equation*}
\descapp{f}{G/H}{G}{gH}{g}{.}
\end{equation*}
\end{comment}
\newcommand{\descapp}[6]{
    #1: #2 &\rightarrow #3\\
    #4 &\mapsto #5#6 
}

\begin{comment}
Permite describir familias de la forma {A_i}_{i\in I}. 
El primer parámtero es el símbolo de un elemento de la familia, por ejemplo A. 
El segundo es el subíndice con el que se van a identificar los miembros, por ejemplo i.
El tercero es el símbolo con el que se denotará a la colección de índices, por ejemplo I.
Así $\arbtfam{A}{i}{I}$.

Los siguientes cuatro comandos realizan algo similar, pero para familias finitas y para cuando se desea o no se desea expecificar un superíndice.
\end{comment}
\newcommand{\arbtfam}[3]{
    {\left\{{#1}_{#2}\right\}}_{#2\in #3}
}
\newcommand{\arbtfmnsub}[3]{
    {\left\{{#1}\right\}}_{#2\in #3}
}
\newcommand{\fntfmnsub}[3]{
    {\left\{{#1}\right\}}_{#2=1}^{#3}
}
\newcommand{\fntfam}[3]{
    {\left\{{#1}_{#2}\right\}}_{#2=1}^{#3}
}
\newcommand{\fntfamsup}[4]{
    \lrbrack{{#1}^{#2}}_{#3=1}^{#4}
}

%Los siguientes dos comandos permiten escribir uplas de elementos, infinitas el primero y finitas el segundo, de la forma (a_i)_{i\in I}.
\newcommand{\arbtuple}[3]{
    {\left({#1}_{#2}\right)}_{#2\in #3}
}
\newcommand{\fntuple}[3]{
    {\left({#1}_{#2}\right)}_{#2=1}^{#3}
}


\newcommand{\gengroup}[1]{
    \left< #1\right>
}

\begin{comment}
Permite escribir el centro de un grupo. Al igual que en los comando previos, la ventaja que tiene es que los paréntesis se ajustan al tamaño del argumento.
Así: $\ringcenter{R}$.
\end{comment}
\newcommand{\ringcenter}[1]{
    C\lrprth{#1}
}

\begin{comment}
Este permite escribir la notación para los Z endomorfismos de un grupo. El primer parámtero es el grupo y el segundo l o r, para saber si son tomados a izquierda o a derecha. 
Así: $\zend{A}{l}$.
\end{comment}
\newcommand{\zend}[2]{
    End_{\mathbb{Z}}^{#2}\lrprth{#1}
}

\begin{comment}
Da la notación para el submódulo generado por un conjunto con respecto a un cierto anillo. 
Así, por ejemplo con $\genmod{R}{X}$, el primer parámetro que recibe es con respecto a qué anillo se genera el submódulo (R) y el segundo es el conjunto que lo genera (X).
\end{comment}
\newcommand{\genmod}[2]{
    \left< #1\right>_{#2}
}

\begin{comment}
Da la notación para el reticulado de submódulos de un módulo dado.
\end{comment}
\newcommand{\genlin}[1]{
    \mathscr{L}\lrprth{#1}
}

%Este coloca "op" como exponente del argumento que recibe. Útil para denotar al anillo opuesto, así como sus elementos, o bien funciones/acciones opuestas.
\newcommand{\opst}[1]{
    {#1}^{op}
}

\begin{comment}
Este comando permite escribir R-módulos a izquierda, o bien a derecha a través de tres parámetros. Por ejemplo $\ringmod{R}{M}{OPCIONES}$. 
El primero parámetro es el anillo con respecto al cual se está trabajando.
El segundo parámtero es el grupo abeliano que tiene estructura de R-módulo.
El tercer parámetro, OPCIONES, admite uno de los siguientes dos valores: l ó r, con los cuales se indica si el módulo es a izquierda (l) o a derecha (r).
Así $\ringmod{S}{M}{r}$ imprimirá que M es un S-módulo a derecha.
\end{comment}
\newcommand{\ringmod}[3]{
    \if#3l
    {}_{#1}#2
    \else
        \if#3r
            #2_{#1}
        \fi
    \fi
}

\begin{comment}
Este comando permite escribir bimódulos a izquierda, o bien a derecha a través de cuatro parámetros. Por ejemplo $\ringbimod{R}{S}{M}{OPCIONES}$. 
Los primeros dos parámetros son los anillos con respecto a los cuales se está generando el bimódulo.
El tercer parámtero es el grupo abeliano que tiene estructura de bimódulo.
El cuarto parámetro, OPCIONES, admite uno de los siguientes tres valores: l, r ó lr. Con los cuales se indica si el bimódulo es a izquierda (l), a derecha (r) o a izquierda y derecha (lr).
Así $\ringbimod{R}{S}{M}{lr}$ imprimirá que M es un R-izquierdo y S-derecho bimódulo.
\end{comment}
\newcommand{\ringbimod}[4]{
    \if#4l
    {}_{#1-#2}#3
    \else
        \if#4r
        #3_{#1-#2}
        \else 
            \ifstrequal{#4}{lr}{
            {}_{#1}#3_{#2}
            }
        \fi
    \fi
}

\begin{comment}
Este comando permite escribir el conjunto de morfismos de R-módulos entre dos R-módulos dados, a través de tres parámetros. 
El primer parámetro es el anillo que actúa sobre los módulos.
El segundo es el módulo que se tomará como dominio de los morfismos.
El tercero es el módulo que se tomará como contradominio de los morfismos.
\end{comment}
\newcommand{\ringmodhom}[3]{
	Hom_{#1}\lrprth{#2,#3}
}

\title{Lista 1}
\author{}
\date{}

\theoremstyle{definition}
\newtheorem{define}{Definición}

\theoremstyle{plain}
\newtheorem{teor}{Teorema}[section]

\theoremstyle{plain}
\newtheorem{prop}{Proposición}[section]

\theoremstyle{definition}
\newtheorem{ejemp}{Ejemplo}[section]

\theoremstyle{definition}
\newtheorem*{coro}{Corolario} 

\theoremstyle{definition}
\newtheorem*{obs}{Observaci\'on}

\theoremstyle{definition}
\newtheorem*{pron}{Proposición}

\theoremstyle{definition}
 
\newtheorem{lem}{Lema}

\theoremstyle{definition}
\newtheorem*{nota}{Nota}
\begin{comment}
\begin{equation*}
    \descapp{f}{G/H}{G}{gH}{g}{.}
\end{equation*}
\end{comment}
\begin{document}

\maketitle
\begin{enumerate}[label=\textbf{Ej \arabic*.}]
\item
    \item
    \item Sea $\lrprth{R,K\varphi}\in K-Alg$. La función 
    \begin{align*}
        \descapp{\bullet_\varphi}{K\times R}{R}{(k,r)}{k\bullet r:=\varphi\lrprth{k}r}{}
    \end{align*}
    es una acción compatible de $K$ en $R$.
    \begin{proof}
    Como $\lrprth{R,K,\varphi}\in K-Alg$ entonces $K$ es un anillo conmutativo.\\
    $\boxed{\text{(AC1)}}$ Sean $k\in K$ y $r_1,r_2\in R$. Así
    \begin{align*}
        k\bullet_\varphi\lrprth{r_1+r_2}&=\varphi\lrprth{k}\lrprth{r_1+r_2}\\
        &=\varphi\lrprth{k}r_1+\varphi\lrprth{k}r_2\\
        &=k\bullet_\varphi r_1+k\bullet_\varphi r_2.
    \end{align*}
    $\boxed{\text{(AC2)}}$ Sean $k_1,k_2\in K$ y $r\in R$. Así
    \begin{align*}
        \lrprth{k_1+k_2}\bullet_\varphi r&=\varphi\lrprth{k_1+k_2}r\\
        &=\lrprth{\varphi(k_1)+\varphi(k_2)}r\\
        &=\varphi(k_1)r+\varphi(k_2)r\\
        &=k_1\bullet_\varphi r+k_2\bullet_\varphi r.
    \end{align*}
    $\boxed{\text{(AC3)}}$ Sean $k_1,k_2\in K$ y $r\in R$. Así
    \begin{align*}
        k_1\bullet_\varphi\lrprth{k_2\bullet_\varphi r}&=\varphi\lrprth{k_1}\lrprth{k_2\bullet_\varphi r}\\
        &=\varphi\lrprth{k_1}\lrprth{\varphi\lrprth{k_2}r}\\
        &=\lrprth{\varphi\lrprth{k_1}\varphi\lrprth{k_2}}r\\
        &=\lrprth{\varphi\lrprth{k_1k_2}}r\\
        &=\lrprth{k_1k_2}\bullet_\varphi r.
    \end{align*}
     $\boxed{\text{(AC4)}}$ Sean $k\in K$ y $r_1,r_2\in R$. Así
    \begin{align*}
        k\bullet_\varphi\lrprth{r_1r_2}&=\varphi(k)\lrprth{r_1r_2}\\
        &=\lrprth{\varphi(k)r_1}r_2\\
        &=\lrprth{k\bullet\varphi r_1}r_2.
        \intertext{Pero también}
        \lrprth{\varphi(k)r_1}r_2&=\lrprth{r_1\varphi(k)}r_2 && ,\ Im\lrprth{\varphi}\subseteq \ringcenter{R}\\
        &=\lrprth{k\bullet\varphi r_1}r_2.\\
        &=r_1\lrprth{\varphi(k)r_2}\\
        &=r_1\lrprth{k\bullet_\varphi r_2}.
    \end{align*}
    $\boxed{\text{(AC5)}}$ Sean $r\in R$. Así
    \begin{align*}
        1_K\bullet_\varphi r&=\varphi(1_K)r\\
        &=1_R\cdot r && ,\ \varphi\text{ es un morfismo de anillos.}\\
        \therefore & \ \lrprth{R,\bullet_\varphi}\in K_{Ac}-Rings.
    \end{align*}
    \end{proof}
    \item 
    \item 
    \item Sea $R$ un anillo.
    \begin{enumerate}[label=(\alph*)]
        \item Si $\lrprth{\lambda, M}\in {}_RRep$ y la función $\bullet_{\lambda}$ está definida como
        \begin{align*}
            \descapp{\bullet_{\lambda}}{R\times M}{M}{\lrprth{r,m}}{r\bullet_{\lambda}m:=\lambda(r)\lrprth{m}}{,}
        \end{align*}
        entonces $({}_RM,\bullet_{\lambda})\in{}_{R}Mod$.
        \item Sea $\lrprth{{}_RM,\bullet}\in{}_{R}Mod$ y la función $\lambda_\bullet$ definida como
        \begin{align*}
            \descapp{\lambda_\bullet}{R}{End_\mathbb{Z}^{l}}{r}{\lambda_\bullet(r)}{,}
            \intertext{con}
            \descapp{\lambda_\bullet\lrprth{r}}{M}{M}{m}{r\bullet m}{.}
        \end{align*}
        Entonces $\lrprth{\lambda_\bullet,M}\in {}_RRep$.
        \item Existe una biyección entre ${}_RRep$ y ${}_RMod$.
    \end{enumerate}
    \begin{proof}
    $\boxed{\text{(a)}}$ Como $\lrprth{\lambda,M}\in{}_RRep$ entonces $M$ es un grupo abeliano.\\
    $\boxed{\text{(RMI1)}}$ Sean $r\in R, m_1,m_2\in M$. Entonces
    \begin{align*}
        r\bullet_{\lambda}\lrprth{m_1+m_2}&=\lambda(r)\lrprth{m_1+m_2}\\
        &=\lambda(r)\lrprth{m_1}+\lambda(r)\lrprth{m_2} && ,\ \lambda(r)\in \zend{M}{}\\
        &=r\bullet_\lambda m_1+r\bullet_\lambda m_2.
    \end{align*}
    $\boxed{\text{(RMI2)}}$ Sean $r_1,r_2\in R, m\in M$. Entonces
    \begin{align*}
        \lrprth{r_1+r_2}\bullet_\lambda m &=\lambda\lrprth{r_1+r_2}\lrprth{m}\\
        &=\lrprth{\lambda(r_1)+\lambda(r_2)}\lrprth{m} && ,\ \lambda\text{ es un morfismo de anillos}\\
        &=\lambda(r_1)\lrprth{m}+\lambda(r_2)\lrprth{m}\\
        &=r_1\bullet_\lambda m+r_2\bullet_\lambda m.
    \end{align*}
    $\boxed{\text{(RMI3)}}$ Sean $r_1,r_2\in R, m\in M$. Entonces
    \begin{align*}
        r_1\bullet_\lambda\lrprth{r_2\bullet_\lambda m}&= \lambda(r_1)\lrprth{r_2\bullet_\lambda m}\\
        &=\lambda(r_1)\lrprth{\lambda(r_2)\lrprth{m}}\\
        &=\lambda(r_1)\circ\lambda(r_2)\lrprth{m}\\
        &=\lambda(r_1r_2)\lrprth{m} && ,\ \lambda\text{ es un morfismo de anillos}\\
        &=\lrprth{r_1r_2}\bullet_\lambda m.
    \end{align*}
    $\boxed{\text{(RMI4)}}$ Sea $m\in M$. Entonces
    \begin{align*}
        1_R\bullet_\lambda m&=\lambda(1_R)\lrprth{m}\\
        &=Id_M\lrprth{m} && ,\ \lambda\text{ es un morfismo de anillos}\\
        &=m.\\
        \therefore\ \lrprth{{}_RM,\bullet_\lambda}\in{}_RMod.
    \end{align*}
    $\boxed{\text{(b)}}$ Como $\lrprth{{}_RM,\bullet_\lambda}\in{}_RMod$ entonces $M$ es un grupo abeliano.\\
    Sea $r\in R$ y $m,n\in M$. Entonces
    \begin{align*}
        \lambda_\bullet(r)\lrprth{m+n}&=r\bullet\lrprth{m+n}\\
        &=r\bullet m+r\bullet n\\
        &=\lambda_\bullet(r)\lrprth{m}+\lambda_\bullet(r)\lrprth{m}\\
        &\implies \lambda_\bullet(r)\in\zend{M}{}.
    \end{align*}
    Si consideramos la composición usual de funciones $\circ$ entonces $\lambda_\bullet(r)\in\zend{M}{l}$, así la aplicación $\lambda_\bullet$ es una función bien definida.\\
    Sean $r_1, r_2\in R$. Si $m\in M$ se tiene que
    \begin{align*}
        \lambda_\bullet(r_1+r_2)\lrprth{m}&=\lrprth{r_1+r_2}\bullet m\\
        &=r_1\bullet m+ r_2\bullet m\\
        &=\lambda_\bullet(r_1)\lrprth{m}+\lambda_\bullet(r_2)\lrprth{m}\\
        &=\lrprth{\lambda_\bullet(r_1)+\lambda_\bullet(r_1)}\lrprth{m}.\\
        \implies \lambda_\bullet(r_1+r_2)&={\lambda_\bullet(r_1)+\lambda_\bullet(r_2)}.
        \intertext{Y}
        \lambda_\bullet(r_1r_2)\lrprth{m}&=\lrprth{r_1r_2}\bullet m\\
        &=r_1\bullet \lrprth{r_2\bullet m}\\
        &=\lambda_\bullet(r_1)\lrprth{r_2\bullet m}\\
        &=\lambda_\bullet(r_1)\lrprth{\lambda_\bullet(r_2)\lrprth{m}}\\
        &=\lambda_\bullet(r_1)\circ\lambda_\bullet(r_2)\lrprth{m}\\
        \implies \lambda_\bullet(r_1r_2)&={\lambda_\bullet(r_1)\circ\lambda_\bullet(r_2)}.
        \intertext{Finalmente}
        \lambda_\bullet(1_R)\lrprth{m}&=1_R\bullet m\\
        &=m\\
        \implies \lambda_\bullet(1_R)&=Id_{M}.
    \end{align*}
    Por lo tanto $\lambda_\bullet:R\rightarrow \zend{M}{l}$ es un morfismo de anillos y así $(\lambda_\bullet, M)\in {}_RRep$.\\
    $\boxed{\text{(c)}}$ Consideremos las siguientes aplicaciones:
    \begin{align*}
        \descapp{f}{{}_RRep}{{}_RMod}{\lrprth{\lambda,M}}{\lrprth{{}_RM,\bullet_\lambda}}{;}
        \intertext{con $\bullet_\lambda$ definido como en (a).}
        \descapp{g}{{}_RMod}{{}_RRep}{\lrprth{{}_RM,\bullet}}{\lrprth{\lambda_\bullet,M}}{;}
    \end{align*}
    con $\lambda_\bullet$ definido como en (b).\\
    Por los (a) y (b) las aplicaciones $f$ y $g$ son funciones bien definidas.\\
    Sea $\lrprth{{}_RM,\bullet}\in {}_RMod$. Entonces
    \begin{align*}
        f\circ g\lrprth{\lrprth{{}_RM,\bullet}}&=f\lrprth{g\lrprth{\lrprth{{}_RM,\bullet}}}\\
        &=f\lrprth{\lrprth{\lambda_\bullet,M}}\\
        &=\lrprth{{}_RM,\bullet_{\lambda_\bullet}}.
        \intertext{Sean $r\in R$ y $m\in M$. Así}
        r\bullet_{\lambda_\bullet}m&=\lambda_\bullet(r)\lrprth{m}\\
        &=r\bullet m\\
        &\implies \bullet=\bullet_{\lambda_\bullet}.\\
        &\implies f\circ g\lrprth{\lrprth{{}_RM,\bullet}}=\lrprth{{}_RM,\bullet}\\
        \implies f\circ g&=Id_{{}_RMod}.
        \intertext{Ahora, sea $\lrprth{\lambda,M}\in {}_RRep$. Luego}
         g\circ f\lrprth{\lrprth{\lambda,M}}&=g\lrprth{f\lrprth{\lrprth{\lambda,M}}}\\
         &=g\lrprth{\lrprth{{}_RM,\bullet_\lambda}}\\
         &=\lrprth{\lambda_{\bullet_\lambda},M}.
         \intertext{Sea $r\in R$ y $m\in M$. Se tiene que}
         \lambda_{\bullet_\lambda}(r)\lrprth{m}&=r\bullet_\lambda m\\
         &=\lambda(r)\lrprth{m}\\
         &\implies \lambda_{\bullet_\lambda}(r)=\lambda(r)\\
         &\implies \lambda_{\bullet_\lambda}=\lambda\\
         &\implies g\circ f\lrprth{\lrprth{\lambda,M}}=\lrprth{\lambda, M}\\
         \implies g\circ f &=Id_{{}_RRep}.
    \end{align*}
    De modo que $f$ es invertible, con inversa $g$, y por lo tanto es una biyección, con lo cual se tiene lo deseado.
    \end{proof}
    \item 
    \item 
    \item Sea $R$ un anillo con su producto denotado por medio de yuxtaposición. Entonces
    \begin{enumerate}[label=(\alph*)]
        \item si la función $\bullet$ está definida como
        \begin{align*}
            \descapp{\bullet}{R\times R}{R}{(r,x)}{r\bullet x:=rx}{,}
        \end{align*}
        $\lrprth{{}_RR,\bullet}\in {}_RMod$.
        \item si la función $\bullet$ está definida como
        \begin{align*}
            \descapp{\bullet}{R\times R}{R}{(x,r)}{x\bullet r:=xr}{,}
        \end{align*}
        $(R_R,\bullet)\in Mod_R$.
    \end{enumerate}
    \begin{proof}
    $\boxed{\text{(a)}}$ 
    Sean $r,s,t\in R$. Se tiene lo siguiente como consecuencia de la asociatividad de del producto en $R$ y la distributividad de este con respecto a la suma en $R$:
    \begin{align*}
        r\bullet\lrprth{s+t}&=r\lrprth{s+t}=rs+st\\
        &=r\bullet t + s\bullet t.\\
        \lrprth{r+s}\bullet t&=\lrprth{r+s}\bullet t=rt+st\\
        &=r\bullet t + s\bullet t.\\
        r\bullet\lrprth{s\bullet t}&=r\lrprth{st}=\lrprth{rs}t\\
        &=\lrprth{r\bullet s}\bullet t.\\
        \lrprth{r+s}\bullet t&=\lrprth{r+s}\bullet t=rt+st\\
        &=r\bullet t + s\bullet t.\\
        \intertext{Finalmente, como $1_R$ es el neutro multiplicativo de $R$}
        1_R\bullet r&= 1_Rr=r.
        \therefore \ \lrprth{{}_RR,\bullet}&\in {}_RMod.
    \end{align*}
    $\boxed{\text{(b)}}$ Es análogo al inciso (a), empleando nuevamente a asociatividad de del producto en $R$ y la distributividad de este con respecto a la suma en $R$, así como la propiedad del neutro multiplicativo. \\
    \end{proof}
\end{enumerate}
\end{document}